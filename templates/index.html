<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gesture Canvas</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden; /* Prevent scrollbars */
            background-color: black; /* Optional background color */
        }
        #canvas {
            width: 75%;  /* 75% width for the canvas */
            height: 100%; /* Full height */
            background-color: white; /* White background for drawing */
            position: absolute; /* Position it absolutely */
            left: 0; /* Align to the left */
        }
        #videoContainer {
            position: absolute;
            top: 20px; /* Distance from the top */
            right: 20px; /* Distance from the right */
            width: 20%; /* Small width for the video feed */
            height: 20%; /* Small height for the video feed */
        }
        #video {
            width: 100%; /* Full width of the container */
            height: 100%; /* Full height of the container */
            object-fit: cover; /* Maintain aspect ratio */
        }
        #save-btn {
            position: absolute;
            top: 20px;  /* Distance from the top */
            left: 20px; /* Distance from the left */
            padding: 10px;
            background-color: green;
            color: white;
            border: none;
            cursor: pointer;
            z-index: 100; /* Ensure the button is above other elements */
        }
    </style>
</head>
<body>
    <h1 style="color: white; position: absolute; top: 20px; left: 20px; z-index: 100;">Gesture Canvas with Write and Erase Modes</h1>
    <canvas id="canvas"></canvas>
    <div id="videoContainer">
        <img id="video" src="{{ url_for('video_feed') }}">
    </div>
    <button id="save-btn">Save Drawing</button>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const saveButton = document.getElementById('save-btn');
        const videoStream = document.getElementById('video');
        
        // Set canvas size to fill the 75% width
        function resizeCanvas() {
            canvas.width = window.innerWidth * 0.75; // 75% of window width
            canvas.height = window.innerHeight; // Full window height
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas(); // Initial canvas size

        // Draw the camera feed onto the canvas
        function draw() {
            ctx.drawImage(videoStream, 0, 0, canvas.width, canvas.height); // Draw video on canvas
            requestAnimationFrame(draw); // Request to draw the next frame
        }

        // Start drawing the video stream
        videoStream.onload = function() {
            draw(); // Start drawing when the video stream is ready
        };

        saveButton.addEventListener('click', () => {
            const link = document.createElement('a');
            link.href = canvas.toDataURL(); // Convert canvas to data URL
            link.download = 'gesture_drawing.png'; // Set the download filename
            link.click(); // Trigger the download
        });

        // Drawing functionality on the canvas
        let drawing = false;
        let previousPoint = null;

        canvas.addEventListener('mousedown', (e) => {
            drawing = true;
            previousPoint = { x: e.clientX - canvas.offsetLeft, y: e.clientY - canvas.offsetTop };
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!drawing) return;
            const currentPoint = { x: e.clientX - canvas.offsetLeft, y: e.clientY - canvas.offsetTop };
            ctx.beginPath();
            ctx.moveTo(previousPoint.x, previousPoint.y);
            ctx.lineTo(currentPoint.x, currentPoint.y);
            ctx.strokeStyle = 'red'; // Color for drawing
            ctx.lineWidth = 5; // Thickness of the line
            ctx.stroke();
            previousPoint = currentPoint;
        });

        canvas.addEventListener('mouseup', () => {
            drawing = false;
        });

        canvas.addEventListener('mouseleave', () => {
            drawing = false;
        });
    </script>
</body>
</html>
